+++
title = "CMSC216"
author = ["ksam"]
date = 2022-01-26
lastmod = 2022-04-23T10:01:11-04:00
draft = false
slug = "CMSC216"
description = "Notes from UMD's CMSC216 class"
math = true
+++

## C Syntax {#c-syntax}


### Preprocessor Directives {#preprocessor-directives}

Code at the beginning of a file that starts with a #. This is run before compilation.

{{< code language="c" line-numbers="&quot;true&quot;" title="Preprocessor Directives" isCollapsed="true" >}}
\#include &lt;stdio.h&gt;
\#include &lt;stdlib.h&gt;
\#include &lt;string.h&gt;
\#define MAX_COLS 20 _\* max # of columns to process \*_
\#define MAX_INPUT 1000
{{< /code >}}

`#define` defines a constant value, `#include` includes another file's declarations.


### Main Function {#main-function}

-   Returns an int, takes no arguments (so void)

{{< code language="c" line-numbers="&quot;true&quot;" title="Main Function" isCollapsed="true" >}}
int main(void){
    _\* Some code \*_
    return 0;
}
{{< /code >}}


### Prototypes {#prototypes}

-   The first function "declaration"
-   No body
-   Placed at the top to allow the compiler to do proper type checking


## Basic Concepts {#basic-concepts}


### Environments {#environments}


#### Translation Environment {#translation-environment}

-   Source code get compiled into object code
-   Which then gets linked with other object code by the linker to form a single executable


#### Execution Environment {#execution-environment}

-   The code is then excuted by loading it into memory (an os is not neccessary but usually used), setting it up, running it, and terminating it by returning [main's](#main-function) error code.


### Lexical Rules {#lexical-rules}


#### Trigraphs {#trigraphs}

-   A 3-sequence of a characters that may not be easily typeable


#### Comments {#comments}

-   Begin with `/*` and end with `*/`
-   Can be multiple lines, by not nested
    -   If they're multiple lines, they get everything on those lines


### Declaration {#declaration}

-   A declaration causes memory to be reserved for the variable
-   There is no extra instantiation
-   If variables are uninitialized they'll just have garbage values


### Expression and assignment {#expression-and-assignment}

-   Assignment returns the value the variable was assigned
-   An expression can be a simple statement, its just not useful unless it has a side effect


#### Side Effect {#side-effect}

-   A change in program state


### Booleans in C {#booleans-in-c}

-   There is no boolean type, 0 is false, non-zero is true


### Arithmetic Conversion {#arithmetic-conversion}

-   Both `char` and `short` types are promoted to `int` types when doing math
-   If arithmetic operations are performed with different `int` types, the smaller type is promoted to be the higher type


## Standard Library {#standard-library}


### stdio {#stdio}


#### printf {#printf}

-   `printf` takes in a character string with 0 or more format specifiers, if any are present, it also takes in that many other values after the string
-   They contain escape sequences, format specifiers, and normal characters
-   Format specifiers include
    -   %d for integers
    -   %f for floats
    -   %c for characters
    -   %u for unsigned int decimal
    -   %x for unsigned int hex
    -   %o for unsigned int octal
-   Padding can be done by adding the number of spaces to pad by before the specifier ("%4d")
    -   You can fill with 0s instead by adding a 0 beforehand ("%04d")


#### scanf {#scanf}

-   `scanf` takes in a character string with 0 or more format specifiers, if any are present, it also takes in that many other variable pointers after the string
-   It takes in format specifiers and reads each one into its corresponding variable
-   If too few variables are put in, scanf will wait
-   It too many variables are put in, they will remain in the input
-   If the last data in the input has been read, scanf returns a special `EOF` value
-   Format specifiers include
    -   %d for integers
    -   %f for floats
    -   %c for characters


#### feof {#feof}

-   `feof(stdin)` will be true if the **previous** try to read didn't work because there was no more data
-   You must try to read something for `feof` to work


### assert {#assert}

-   If `assert()` argument is false, it will kill the program


### stddef {#stddef}


## Data {#data}


### Integers {#integers}


#### Values {#values}

`short` &lt;= `int` &lt;= `long`

| Type               | Signedness | Max Start  | Min End    |
|--------------------|------------|------------|------------|
| int                | signed     | -32767     | 32767      |
| unsigned int       | unsigned   | 0          | 65535      |
| short int          | unsigned   | -32767     | 32767      |
| unsigned short int | signed     | 0          | 65535      |
| long int           | signed     | -214783647 | 2147483647 |
| unsigned long int  | unsigned   | 0          | 4294967295 |
| char               | NA         | 0          | 127        |
| signed char        | signed     | -127       | 127        |
| unsigned char      | unsigned   | 0          | 255        |


#### Literals {#literals}

-   Decimals
-   In octal when starting with a 0
-   In hex when starting with an 0x
-   Characters literals in single quotes


#### Promotion {#promotion}


### Enumerated Type {#enumerated-type}


#### Values {#values}

-   Enums are stored as ints
-   The numbers after the name are optional

{{< code language="c" >}}
enum Jar_Type { CUP=8, PINT=16, QUART=32, HALF_GALLON=64, GALLON=128 };
{{< /code >}}


### Floating-Point {#floating-point}

-   Have a decimal point `3.141`
-   Have an exponent `1E10`
-   Or both `6.023e23`


### Pointers {#pointers}

-   Every memory location has an address
-   **Pointer** is another name for address
-   **Pointer Variable** is a variable whose value is an address of a moeory location
-   There are no point constants because we can't predict where memory addresses will be
-   To declare a pointer, use the indirection operator before the variable
    -   The indirection operation gets the value at an address, so therefore the variable stores a pointer to an address with a value of the given type
    -   `int *a` is an in pointer
    -   If you declare multiple on the same line, you need a `*` for each one
    -   When initializing it on the same line, the value you give goes to the variable itself, not the pointer


### String {#string}

-   C has no string type, but there is a string literal
-   A string is a sequence of characters terminated by a `NUL` byte
    -   A sequence of zero characters is valid


### Arrays {#arrays}


#### Declaration {#declaration}

-   Like declaring any variable, but with square brackets after the name with a capacity value: `int values[20]`
-   Array sizes must be constants at compile time, so literals or [symbolic constants](#preprocessor-directives)


#### Initialization {#initialization}

-   You can't assign variables to each other or compare entire arrays
-   You can initialize an array when you declare it by setting it equal to values in curly braces: `int values[20] = {1,2,3}`
    -   This sets the first 3 items to 1,2, and 3 respectively and fills the others with 0
    -   If you pass fewer, it fills the rest with 0s, but you need at least 1


#### Behavior {#behavior}

-   Array parameters don't take sizes (at least for one-dimensional arrays)
-   Arrays are passed by value but act like they're passed by reference, because of [Pointers](#pointers)
-   Arrays don't keep track of their length
-   Accessing an invalid index won't be an error itself but can cause one by accessing or changing memory its not supposed to


### `Typedef` {#typedef}


### Scope {#scope}


#### Block Scope {#block-scope}

-   Exists within the block
-   Have [No Linkage](#no-linkage)


#### File Scope {#file-scope}

-   Exists within the whole file
-   Have [External Linkage](#external-linkage)


#### Shadowing {#shadowing}

-   The variable with the narrowest scope will shadow the other(s)


### Linkage {#linkage}

-   Determines if multiple instances of the same identifier refer to the same thing or not


#### No Linkage {#no-linkage}

-   All occurrences are different


#### Internal Linkage {#internal-linkage}

-   All occurrences in a given file are the same


#### External Linkage {#external-linkage}

-   All occurrences are the same


#### Changing Linkage {#changing-linkage}

-   `extern` will change a [Block Scope](#block-scope) variable from no linkage to external
-   `static` will change a [File Scope](#file-scope) variable from external linkage to internal


### Storage {#storage}

-   Determines the lifetime of the memory of the variable while the program is executing
-   It's still accessible only from within its [Scope](#scope), but controls when the value's memory gets destroyed


### const {#const}


### Structures {#structures}


### Unions {#unions}

\*\*


## Operators {#operators}


### Unary {#unary}


#### Negation {#negation}

-   `-`
-   flips the sign


#### Increment/Decrement {#increment-decrement}

-   `++` / `--`
-   Increments/Decrements by 1
-   Before the expression computes before substituing the expression
-   After expression changes the variable after substitution, so the existing value is used.


#### Size {#size}

-   `sizeof`
-   Gets the size in `size_t` of a given value


#### Comma {#comma}

-   `expr1,exp2`
-   Evaluates its first operand and then the right one, producing the right's output as its own


#### Indirection {#indirection}

-   `*`
-   Gets the value at the given address


#### Address {#address}

-   `&`
-   Gets the address a given value is stored at


### Logical {#logical}

-   Both `&&` and `||` use short circuit evaluation


### Bitshifts {#bitshifts}


#### Left Shift {#left-shift}

-   `value << n`
-   shifts `value`'s bits left by `n` positions
    -   Rightmost bits get 0, leftmost bits get discarded


#### Right Shift {#right-shift}

-   `value >> n`
-   shifts `value`'s bits right by `n` positions
    -   If unsigned, the leftmost bits get 0
    -   If signed, whether the leftmost bits get 0 or 1 is implementation dependent


### Bitwise {#bitwise}

-   And (`&`): Ands two bits
-   Or (`|`): Ors two bits
-   Xor (`^`): Xors two bits
-   Complement (`~`): Negates 1 bit


#### Masking {#masking}

-   We can construct masks to select only certain bits from multiple of them


### rvalues and lvalues {#rvalues-and-lvalues}

-   rvalues can appear on the right hand side of an assignment
-   lvalues can appear on the left hand side of an assignment


### Evaluation {#evaluation}

-   Order of evaluation goes first by precedence, then associativity, and finally unspecified as long as `&&`, `||`, `()`, `?:`, and `,` work


#### Precedence {#precedence}

-   Order of given operators


#### Associativity {#associativity}

-   Whether to operate left to right or left to right


## Pointers {#pointers}

-   A pointer is a variable that holds the address of something in memory
-   Pointers can be [rvalues and lvalues](#rvalues-and-lvalues) but addresses can only be rvalues
-   Pointer declarations must be initialized
-   Functions can return a pointer but you must ensure the variable will not be destroyed after the function leaves


### NULL Pointer {#null-pointer}

-   Special values that pointer can have that doesn't point anywhere
-   Defined in [stddef](#stddef)


## Make {#make}

-   `make` autobuilds programs by using separate compilation to efficiently only build what's needed using a user defined dependency hierarchy
-   A Makefile has multiple rules
    -   A rule consits of a target, a dependency list, and a set of actions
    -   The target is the name/identifier of the rule and it can specifically be built with `make target`
    -   The dependency list follows the target and a colon and an update to any of these dependency files will cause the target's action(s) to run
    -   Each action line follows a target line and starts with a tab character. Each action line is run when the target needs to be rebuilt
-   A dependency will cause the target to be rebuilt if its newer than the target
-   An error in a given action line will cause the action lines following it to not run unless the action line starts with a `-` which will allow actions lines following to continue to run even if the current one fails
-   Comments start with a `#` and lines can be broken onto following ones with a `\`
-   Makefiles provide macros that represent a predefined value defined at the start of the makefile and repeatedly used within it
    -   They're defined with `name=value` and used with `$(name)`
    -   `CC` is the name for the c compiler, and `CFLAGS` is the name for options to use with the compiler
-   Makefiles often have targets that aren't true files, like `all` and `clean`, which are phony targets


## Dynamic Memory Allocation {#dynamic-memory-allocation}

-   Most data in C is stored on the stack, but sometimes we want to store dynamic variables whose size we can't predict at compile time
-   Dynamic memory allocation allows us to request memory to use while the program is running


### `malloc` {#malloc}

-   malloc allocates space of the given size and returns a pointer to it, without intializing the memory
-   returns NULL if error


### `free` {#free}

-   free releases the memory at the pointer
-   the pointer must point to the start of dynamically allocated memory
-   you must free all memory dynamically allocated if you want to avoid leaks
-   free does nothing other than release memory
-   free(NULL) does nothing


### `calloc` {#calloc}

-   calloc allocates spaces to store `num` things of each `size` and initializes all the memory to 0
-   returns NULL if an error


### `realloc` {#realloc}

-   reallocates dynamically allocated memory at `ptr` with `new_size`
-   Copies space over to the new space if it can't be done in the same current space


## Structures &amp; Pointers {#structures-and-pointers}

-   Structures can be self-referential by containing a pointer to its structure tag
-   Structures can contain each other by using a partial struct declaration (just `struct name`), declaring the other struct, and then fully defining the partially defined struct


## Strings {#strings}

-   Strings are character arrays with a terminating `NUL` byte (which does not count for its length)
-   `strlen(char const *string)` returns the length of the string without its terminating `NUL` byte
    -   it returns an unsigned int so a combination of its return values can never be negative
-   Unrestricted functions
    -   `strcpy(char *dst, char const *src)` copies the string from src into dst
    -   `strcat(char *dst, char const *src)` copies the string in src to the end of dst
    -   `strcmp(char const *s1, char const *s2)` compares two strings lexicographically
    -   These functions assume a `NUL` byte exists and will run until it is found, which may not always be the case
    -   An equivalent version of each of the functions exists (`strncpy`, `strncat`, `strncmp`) that take an extra length parameter and only go up until there
    -   `strchr(char const *str, int ch)` searches for a character from the left
    -   `strrchr(char const *str, int char)` searches for a character from the right
    -   `strpbrk(char const *str, char const *group)` searches for a group of characters from the left
    -   `strstr(char const *s1, char const *s2)` searches for a substring


## Command Line Arguments {#command-line-arguments}

-   `main(int argc, char *argv[])` is a valid declaration for main
    -   `argc` is the number of arguments when called, including the name
    -   `argv` is that list, with the first being the name, and `argv[argc]` being NULL
    -   It's also possible for main to take a third parameter `char *envp[]`, which is an array of strings in the form `KEYWORD=VALUE` for all environment variables


## The Preprocessor {#the-preprocessor}


## Process Control {#process-control}


## I/O {#i-o}


## Assembly {#assembly}
